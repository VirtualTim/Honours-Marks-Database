package orm;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.StatisticsCalculator;
import sessionControl.Session;

/**
 * Base Class representing a SubAssessment.
 * 
 * @author Jonathan Chua
 * @author Samuel Widenbar
 * @version 16/10/2013
 */
public class BaseSubAssessment {
    /**
     * Primary key identifying the SubAssessment, auto-generated by the database.
     */
    private int subAssessmentID;
    
    /**
     * Name of the SubAssessment, exists as a String in the database.
     */
    public StringBuffer name = new StringBuffer (30);
    
    /**
     * The Assessment that this SubAssessment belongs to.
     */
    private Assessment parentAssessment;
    
    /**
     * The highest mark scored for this SubAssessment.
     */
    public StringBuffer maxMark = new StringBuffer (6);
    
    /**
     * The percentage weight this SubAssessment has in the whole Assessment, existing as an Integer in the database.
     */
    public StringBuffer assessmentPercent = new StringBuffer (6);
    
    /**
     * All the marks for a student related to this SubAssessment.
     */
    private List<Mark> marks = new ArrayList<Mark>();
    
    /**
     * The calculated average mark scored for this SubAssessment, existing as a double.
     */
    public StringBuffer aveMark = new StringBuffer(6);
	
	/**
	 * The calculated standard deviation for this SubAssessment, existing as a double.
	 */
    public StringBuffer standDev = new StringBuffer(6); 
    
	/**
	 * The calculated range for this SubAssessment, existing as a string buffer.
	 */
    public StringBuffer range = new StringBuffer(13);

    
    /**
     * Constructor to create an object to retrieve and store a sub assessment found in the database.
     * 
     * Contains all information about this sub assessment. Non-specific to students.
     * 
     * @param subAssessmentID the subassessment ID
     * @param assessment the parent assessment
     */
    public BaseSubAssessment(int subAssessmentID, Assessment assessment) {
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentRS = s.executeQuery("SELECT * FROM SubAssessment WHERE SubAssessmentID=" + subAssessmentID)) {
            
            // There will only be one subAssessment returned as subAssessmentID is unique
            // Called with this constructor, no data about marks will exist
            while (subassessmentRS.next()) {
                setSubAssessmentID(subAssessmentID);
                setName(subassessmentRS.getString("SubAssessmentName"));
                setMaxMark(subassessmentRS.getInt("MaxMarks"));
                setAssessmentPercent(subassessmentRS.getInt("AssessmentPercent"));
                this.parentAssessment = assessment;
            }
        } catch (SQLException ex) {
            Logger.getLogger(BaseSubAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    	
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentMarksRS = s.executeQuery("SELECT * FROM SubAssessmentMark WHERE SubAssessmentID=" + subAssessmentID)) {
            
            // Will be a list of subAssessments marks returned, as many subAssessments marks can belong to a subassessment
            // We are adding all of them to the list
            while (subassessmentMarksRS.next()) {
            	Mark nextMark = new Mark(subAssessmentID, subassessmentMarksRS.getInt("StudentID"), subassessmentMarksRS.getInt("MarkerID"), (SubAssessment) this);
                this.marks.add(nextMark);
            }
            
            setAveMark(StatisticsCalculator.subAssessAve(subAssessmentID));
        } catch (SQLException ex) {
            Logger.getLogger(BaseAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /**
     * Constructor to create an object to retrieve and store a sub assessment found in the database.
     * 
     * Runs when creating a subAssessment for CohortData.subassessments - single 'master' subassessment object for each subassessment ID,
     * containing all related marks for that subassessment. Does not have a parent assessment.
     * 
     * @param subAssessmentID the ID of the subassessment
     */
    public BaseSubAssessment(int subAssessmentID) {
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentRS = s.executeQuery("SELECT * FROM SubAssessment WHERE SubAssessmentID=" + subAssessmentID)) {
            
            // There will only be one subAssessment returned as subAssessmentID is unique
            // Called with this constructor, no data about marks will exist
            while (subassessmentRS.next()) {
                setSubAssessmentID(subAssessmentID);
                setName(subassessmentRS.getString("SubAssessmentName"));
                setMaxMark(subassessmentRS.getInt("MaxMarks"));
                setAssessmentPercent(subassessmentRS.getInt("AssessmentPercent"));
            }
        } catch (SQLException ex) {
            Logger.getLogger(BaseSubAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    	
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentMarksRS = s.executeQuery("SELECT * FROM SubAssessmentMark WHERE SubAssessmentID=" + subAssessmentID)) {
            // Will be a list of subAssessments marks returned, as many subAssessments marks can belong to a subassessment
            // We are adding all of them to the list
            while (subassessmentMarksRS.next()) {
            	Mark nextMark = new Mark(subAssessmentID, subassessmentMarksRS.getInt("StudentID"), subassessmentMarksRS.getInt("MarkerID"), (SubAssessment) this);
                this.marks.add(nextMark);
            }
        } catch (SQLException ex) {
            Logger.getLogger(BaseAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /**
     * Constructor to create an object to retrieve and store a sub assessment found in the database related to a specific student.
     * 
     * @param subAssessmentID subassessment ID
     * @param studentID student's ID
     * @param assessment parent of the subassessment
     */
    public BaseSubAssessment(int subAssessmentID, int studentID, Assessment assessment) {
    	this.marks = new ArrayList<>();
    	
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentRS = s.executeQuery("SELECT * FROM SubAssessment WHERE SubAssessmentID=" + subAssessmentID)) {
            
            // There will only be one subAssessment returned as subAssessmentID is unique
            // Called with this constructor, no data about marks will exist
            while (subassessmentRS.next()) {
                setSubAssessmentID(subAssessmentID);
                setName(subassessmentRS.getString("SubAssessmentName"));
                setMaxMark(subassessmentRS.getInt("MaxMarks"));
                setAssessmentPercent(subassessmentRS.getInt("AssessmentPercent"));
                this.parentAssessment = assessment;
            }
        } catch (SQLException ex) {
            Logger.getLogger(BaseSubAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    	
    	try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet subassessmentMarksRS = s.executeQuery("SELECT MarkerID FROM SubAssessmentMark WHERE SubAssessmentID=" + subAssessmentID + " AND StudentID =" + studentID)) {
            
            // Will be a list of subAssessments marks returned, as many subAssessments marks can belong to a subassessment
            // We are adding all of them to the list
            while (subassessmentMarksRS.next()) {
            	Mark nextMark = new Mark(subAssessmentID, studentID, subassessmentMarksRS.getInt("MarkerID"), (SubAssessment)this);
                this.marks.add(nextMark);
            }
        } catch (SQLException ex) {
            Logger.getLogger(BaseAssessment.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /**
     * Constructor that creates a new object with the given data and insert it into the database.
     * 
     * The sub assessment ID will be auto-generated by the database.
     * 
     * @param name the name of the sub assessment
     * @param parentAssessment the Assessment object this sub assessment belongs to
     * @param assessmentPercent the percentage this sub assessment takes up in the parent assessment
     * @throws SQLException when there's an error with the SQL statement
     */
    public BaseSubAssessment(String name, Assessment parentAssessment, int assessmentPercent) throws SQLException {
        try (Statement s = Session.dbConn.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
            s.execute("INSERT INTO SubAssessment(SubAssessmentName, AssessmentID, AssessmentPercent, MaxMarks) VALUES ('"
                    + name + "', "
                    + parentAssessment.getAssessmentID() + ", "
                    + assessmentPercent + ", "
                    + maxMark + ")");
            
            // TODO: Wait if we have autogenerated SubAssessmentID then how do we initialise this?
            setSubAssessmentID(subAssessmentID);
            setName(name);
            setParentAssessment(parentAssessment);
            setAssessmentPercent(assessmentPercent);
            setMaxMark(0);
            setMarks(null);
        } catch (SQLException ex) {
            Logger.getLogger(BaseStudent.class.getName()).log(Level.SEVERE, null, ex);
            throw new SQLException(ex.getMessage());
        }
    }
    
    /**
     * Method to get the sub assessment ID.
     * 
     * @return sub assessment ID
     */
    public int getSubAssessmentID() {
        return subAssessmentID;
    }
    
    /**
     * Method to set the sub assessment ID.
     * 
     * @param subAssessmentID the sub assessment ID
     */
    public void setSubAssessmentID(int subAssessmentID) {
        this.subAssessmentID = subAssessmentID;
    }
    
    /**
     * Method to get the name of the sub assessment.
     * 
     * @return name of the sub assessment
     */
    public StringBuffer getName() {
        return name;
    }
    
    /**
     * Method to set the name of the sub assessment.
     * 
     * @param name the name of the sub assessment
     */
    public void setName(String name) {
    	this.name.replace(0, this.name.capacity(), name);
    }
    
    /**
     * Method to get the parent assessment.
     * 
     * @return the Assessment object this sub assessment belongs to.
     */
    public Assessment getParentAssessment() {
        return parentAssessment;
    }
    
    /**
     * Method to set the parent assessment.
     * 
     * @param parentAssessment the Assessment object that this sub assessment is supposed to belong to
     */
    public void setParentAssessment(Assessment parentAssessment) {
        this.parentAssessment = parentAssessment;
    }
    
    /**
     * Method to get the max mark.
     * @return the maximum mark scored by the students for this sub assessment
     */
    public int getMaxMark() {

    	return Integer.parseInt(maxMark+"");
        
    }
    
    /**
     * Method to set the max mark. If value passed is not a number, sets to a blank string
     * 
     * @param maxMark the maximum mark scored by the students for this sub assessment
     */
    public void setMaxMark(int maxMark) {

		this.maxMark.replace(0, this.maxMark.capacity(),  Integer.toString(maxMark));

    }
    
    /**
     * Method to get the average mark, or 0 if mark isn't a number.
     * 
     * @return the calculated average of all the marks all the students got for this sub assessment
     */
    public double getAveMark() {
    	try {
    		return Double.parseDouble(aveMark+"");
    	}
    	catch (NumberFormatException e) {
    		return 0;
    	}
    }
    
    /**
     * Method to set the average mark. If value passed is not a number, sets to a blank string.
     * 
     * @param aveMark the calculated average of all the marks all the students got for this sub assessment
     */
    public void setAveMark(double aveMark) {
    	if (!Double.isNaN(aveMark)){
	    	this.aveMark.replace(0, this.aveMark.capacity(),  Double.toString(aveMark));
	    	this.aveMark.setLength(5);
    	} else {
    		this.aveMark.replace(0, this.aveMark.capacity(),  " ");
	    	this.aveMark.setLength(1);
    	}
    }
    
    /**
     * Method to get the standard deviation of all the marks for this sub assessment, or 0 if it is not a number
     * 
     * @return the standard deviation
     */
    public double getStandDev() {
    	try {
    		return Double.parseDouble(standDev+"");
    	}
    	catch (NumberFormatException e) {
    		return 0;
    	}

    }
    
    /**
     * Method to set the standard deviation of all the marks for this sub assessment.  If value passed is not a number, sets to a blank string.
     * 
     * @param standDev the standard deviation
     */
    public void setStandDev(double standDev) {
    	if (!Double.isNaN(standDev)){
    		this.standDev.replace(0, this.standDev.capacity(),  Double.toString(standDev));
	    	this.standDev.setLength(5);
    	} else {
    		this.standDev.replace(0, this.standDev.capacity(),  " ");
	    	this.standDev.setLength(1);
    	}
    }
    
    /**
     * Returns the string buffer displaying the range of scores over the sub assessment.
     * 
     * @param min minimum score in range
     * @param max maximum score in range
     */
    public StringBuffer getRange() {
    	return range;
    }
    
    /**
     * Sets the string buffer displaying the range of scores over the sub assessment. If one of the values passed is not a number, sets to a blank string.
     * 
     * @param min minimum score in range
     * @param max maximum score in range
     */
    public void setRange(double min, double max) {
    	
    	if (Double.isNaN(min) || Double.isNaN(min)){
    		this.range.replace(0, this.range.capacity(),  " ");
	    	this.range.setLength(1);
	    	
    	} else {
    
    	this.range.replace(0, this.range.capacity(),  Double.toString(min));
    	this.range.setLength(5);
    	this.range.append(" - ");
    	this.range.append(max);
    	this.range.setLength(13);
    	}
    }
    
    /**
     * Method to get the assessment percent.
     * 
     * @return the percentage this sub assessment takes up in the parent assessment
     */
    public double getAssessmentPercent() {
    	return Integer.parseInt(assessmentPercent+"");
    }
    
    /**
     * Method to set the assessment percent.
     * 
     * @param assessmentPercent the percentage this sub assessment takes up in the parent assessment
     */
    public void setAssessmentPercent (int assessmentPercent) {
    	this.assessmentPercent.replace(0, this.assessmentPercent.capacity(),  Integer.toString(assessmentPercent));
    }
    
    /**
     * Method to get the marks given for this sub assessment.
     * 
     * @return a list of Mark objects assigned to this sub assessment
     */
    public List<Mark> getMarks() {
        return marks;
    }
    
    /**
     * Method to set the marks given for this sub assessment.
     * 
     * @param marks a list of Mark objects to be assigned to this sub assessment
     */
    public void setMarks(List<Mark> marks) {
        this.marks = marks;
    }
}
